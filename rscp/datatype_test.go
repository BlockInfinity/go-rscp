package rscp

import (
	"testing"
	"time"

	"github.com/go-test/deep"
)

func TestDataType_String(t *testing.T) {
	tests := []struct {
		name string
		d    DataType
		want string
	}{
		{"None",
			None,
			"None",
		},
		{"Bool",
			Bool,
			"Bool",
		},
		{"Char8",
			Char8,
			"Char8",
		},
		{"UChar8",
			UChar8,
			"UChar8",
		},
		{"Int16",
			Int16,
			"Int16",
		},
		{"UInt16",
			UInt16,
			"UInt16",
		},
		{"Int32",
			Int32,
			"Int32",
		},
		{"Int32",
			Int32,
			"Int32",
		},
		{"Uint32",
			Uint32,
			"Uint32",
		},
		{"Int64",
			Int64,
			"Int64",
		},
		{"Uint64",
			Uint64,
			"Uint64",
		},
		{"Float32",
			Float32,
			"Float32",
		},
		{"Double64",
			Double64,
			"Double64",
		},
		{"Bitfield",
			Bitfield,
			"Bitfield",
		},
		{"CString",
			CString,
			"CString",
		},
		{"Container",
			Container,
			"Container",
		},
		{"Timestamp",
			Timestamp,
			"Timestamp",
		},
		{"ByteArray",
			ByteArray,
			"ByteArray",
		},
		{"Error",
			Error,
			"Error",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.d.String(); got != tt.want {
				t.Errorf("DataType.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDataType_DataTypeMeta_New(t *testing.T) {
	tests := []struct {
		name string
		d    DataType
		size uint16
		want interface{}
	}{
		{"None",
			None,
			0,
			nil,
		},
		{"Bool",
			Bool,
			0,
			new(bool),
		},
		{"Char8",
			Char8,
			0,
			new(int8),
		},
		{"UChar8",
			UChar8,
			0,
			new(uint8),
		},
		{"Int16",
			Int16,
			0,
			new(int16),
		},
		{"UInt16",
			UInt16,
			0,
			new(uint16),
		},
		{"Int32",
			Int32,
			0,
			new(int32),
		},
		{"Uint32",
			Uint32,
			0,
			new(uint32),
		},
		{"Int64",
			Int64,
			0,
			new(int64),
		},
		{"Uint64",
			Uint64,
			0,
			new(uint64),
		},
		{"Float32",
			Float32,
			0,
			new(float32),
		},
		{"Double64",
			Double64,
			0,
			new(float64),
		},
		{"Bitfield",
			Bitfield,
			0,
			new(byte),
		},
		{"CString",
			CString,
			0,
			new(string),
		},
		{"Container",
			Container,
			0,
			new([]Message),
		},
		{"Timestamp",
			Timestamp,
			0,
			new(time.Time),
		},
		{"ByteArray Size(0)",
			ByteArray,
			0,
			make([]byte, 0),
		},
		{"ByteArray Size(10)",
			ByteArray,
			10,
			make([]byte, 10),
		},
		{"Error",
			Error,
			0,
			new(RscpError),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.d.NewEmpty(tt.size)
			if diff := deep.Equal(got, tt.want); diff != nil {
				t.Errorf("New() = %v, want %v\n%s", got, tt.want, diff)
			}
		})
	}
}

func TestDataType_isValidValue(t *testing.T) {
	type args struct {
		v interface{}
	}
	tests := []struct {
		name string
		d    DataType
		args args
		want bool
	}{
		{"None",
			None,
			args{nil},
			true,
		},
		{"wrong None",
			None,
			args{""},
			false,
		},
		{"Bool",
			Bool,
			args{true},
			true,
		},
		{"wrong Bool",
			Bool,
			args{""},
			false,
		},
		{"Char8",
			Char8,
			args{int8(0)},
			true,
		},
		{"wrong Char8",
			Char8,
			args{""},
			false,
		},
		{"UChar8",
			UChar8,
			args{uint8(0)},
			true,
		},
		{"wrong UChar8",
			UChar8,
			args{""},
			false,
		},
		{"Int16",
			Int16,
			args{int16(0)},
			true,
		},
		{"wrong Int16",
			Int16,
			args{""},
			false,
		},
		{"UInt16",
			UInt16,
			args{uint16(0)},
			true,
		},
		{"wrong UInt16",
			UInt16,
			args{""},
			false,
		},
		{"Int32",
			Int32,
			args{int32(0)},
			true,
		},
		{"wrong Int32",
			Int32,
			args{""},
			false,
		},
		{"Uint32",
			Uint32,
			args{uint32(0)},
			true,
		},
		{"wrong Uint32",
			Uint32,
			args{""},
			false,
		},
		{"Int64",
			Int64,
			args{int64(0)},
			true,
		},
		{"wrong Int64",
			Int64,
			args{""},
			false,
		},
		{"Uint64",
			Uint64,
			args{uint64(0)},
			true,
		},
		{"wrong Uint64",
			Uint64,
			args{""},
			false,
		},
		{"Float32",
			Float32,
			args{float32(0)},
			true,
		},
		{"wrong Float32",
			Float32,
			args{""},
			false,
		},
		{"Double64",
			Double64,
			args{float64(0)},
			true,
		},
		{"wrong Double64",
			Double64,
			args{""},
			false,
		},
		{"Bitfield",
			Bitfield,
			args{byte(0)},
			true,
		},
		{"wrong Bitfield",
			Bitfield,
			args{""},
			false,
		},
		{"CString",
			CString,
			args{""},
			true,
		},
		{"wrong CString",
			CString,
			args{0},
			false,
		},
		{"Container",
			Container,
			args{[]Message{}},
			true,
		},
		{"wrong Container",
			Container,
			args{""},
			false,
		},
		{"Timestamp",
			Timestamp,
			args{time.Now()},
			true,
		},
		{"wrong Timestamp",
			Timestamp,
			args{""},
			false,
		},
		{"ByteArray",
			ByteArray,
			args{[]byte{}},
			true,
		},
		{"wrong ByteArray",
			ByteArray,
			args{""},
			false,
		},
		{"Error",
			Error,
			args{RscpError(0)},
			true,
		},
		{"wrong Error",
			Error,
			args{""},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.d.isValidValue(tt.args.v)
			if diff := deep.Equal(got, tt.want); diff != nil {
				t.Errorf("DataType.isValidValue() = %v, want %v\n%s", got, tt.want, diff)
			}
		})
	}
}
