// Code generated by "enumer -type=AuthLevel -json"; DO NOT EDIT.

//
package rscp

import (
	"encoding/json"
	"fmt"
)

const (
	_AuthLevelName_0 = "AUTH_LEVEL_NO_AUTH"
	_AuthLevelName_1 = "AUTH_LEVEL_USER"
	_AuthLevelName_2 = "AUTH_LEVEL_INSTALLER"
	_AuthLevelName_3 = "AUTH_LEVEL_SERVICE"
	_AuthLevelName_4 = "AUTH_LEVEL_ADMIN"
	_AuthLevelName_5 = "AUTH_LEVEL_E3DC"
	_AuthLevelName_6 = "AUTH_LEVEL_E3DC_ROOT"
)

var (
	_AuthLevelIndex_0 = [...]uint8{0, 18}
	_AuthLevelIndex_1 = [...]uint8{0, 15}
	_AuthLevelIndex_2 = [...]uint8{0, 20}
	_AuthLevelIndex_3 = [...]uint8{0, 18}
	_AuthLevelIndex_4 = [...]uint8{0, 16}
	_AuthLevelIndex_5 = [...]uint8{0, 15}
	_AuthLevelIndex_6 = [...]uint8{0, 20}
)

func (i AuthLevel) String() string {
	switch {
	case i == 0:
		return _AuthLevelName_0
	case i == 10:
		return _AuthLevelName_1
	case i == 20:
		return _AuthLevelName_2
	case i == 30:
		return _AuthLevelName_3
	case i == 40:
		return _AuthLevelName_4
	case i == 50:
		return _AuthLevelName_5
	case i == 60:
		return _AuthLevelName_6
	default:
		return fmt.Sprintf("AuthLevel(%d)", i)
	}
}

var _AuthLevelValues = []AuthLevel{0, 10, 20, 30, 40, 50, 60}

var _AuthLevelNameToValueMap = map[string]AuthLevel{
	_AuthLevelName_0[0:18]: 0,
	_AuthLevelName_1[0:15]: 10,
	_AuthLevelName_2[0:20]: 20,
	_AuthLevelName_3[0:18]: 30,
	_AuthLevelName_4[0:16]: 40,
	_AuthLevelName_5[0:15]: 50,
	_AuthLevelName_6[0:20]: 60,
}

// AuthLevelString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func AuthLevelString(s string) (AuthLevel, error) {
	if val, ok := _AuthLevelNameToValueMap[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to AuthLevel values", s)
}

// AuthLevelValues returns all values of the enum
func AuthLevelValues() []AuthLevel {
	return _AuthLevelValues
}

// IsAAuthLevel returns "true" if the value is listed in the enum definition. "false" otherwise
func (i AuthLevel) IsAAuthLevel() bool {
	for _, v := range _AuthLevelValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for AuthLevel
func (i AuthLevel) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for AuthLevel
func (i *AuthLevel) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("AuthLevel should be a string, got %s", data)
	}

	var err error
	*i, err = AuthLevelString(s)
	return err
}
